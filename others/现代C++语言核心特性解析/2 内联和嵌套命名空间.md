---
date: 2024-11-22 11:28:05
date modified: 2024-11-22 11:58:12
title: 内联和嵌套命名空间
tags:
  - cpp
categories:
  - cpp
---
## 内联命名空间的定义和使用

开发一个大型工程必然会有很多开发人员的参与，也会引入很多第三方库，这导致程序中偶尔会碰到同名函数和类型，造成编译冲突的问题。为了缓解该问题对开发的影响，我们需要合理使用命名空间。程序员可以将函数和类型纳入命名空间中，这样在不同命名空间的函数和类型就不会产生冲突，当要使用它们的时候只需打开其指定的命名空间即可，例如:

```cpp
namespace S1 {
	void foo() {}
}

namespace S2 {
	void foo() {}
}

using namespace S1;

int main() {
	foo;
	S2::foo();
}
```

C++11标准增强了命名空间的特性，提出了内联命名空间的概念。 内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了，比如：

```cpp
#include <iostream>

namespace Parent {
	namespace Child1 {
		void foo() { std::cout << "Child1::foo()" << std::endl; }
	}
	inline namespace Child2 {
		void foo() { std::out << "Child2::foo()" << std::endl; }
	}
}

int main() {
	Parent::Child1::foo();
	Parent::foo();
}
```

该特性可以帮助库作者无缝升级库代码，让客户不用修改任何代码也能够自由选择新老库代码。举个例子:

```cpp
#include <iostream>

namespace Parent {
	void foo() { std::cout << "foo v1.0" << std::endl; }
}

int main() {
	Parent::foo();
}
```

请注意，示例代码中只能有一个内联命名空间，否则编译时会造 成二义性问题，编译器不知道使用哪个内联命名空间的foo函数。

## 嵌套命名空间的简化语法

有时候打开一个嵌套命名空间可能只是为了向前声明某个类或者函数，但是却需要编写冗长的嵌套代码，加入一些无谓的缩进，这很难让人接受。幸运的是，C++17标准允许使用一种更简洁的形式描述嵌 套命名空间，例如:

```cpp
namespace A::B::C {
	int foo() { return 5; }
}
```

以上代码等同于：

```cpp
namespace A {
	namespace B {
		namespace C {
			int foo() { return 5; }
		}
	}
}
```

很显然前者是一种更简洁的定义嵌套命名空间的方法。除简洁之外，它也更加符合我们已有的语法习惯，比如嵌套类:

```cpp
std::vector<int>::iterator it;
```

在C++20中，我们可以这样定义内联命名空间：

```cpp
namespace A::B::inline C {
	int foo() { return 5; }
}
// 或者
namespace A::inline B::C {
	int foo() { return 5; }
}
```

他们分别等同于：

```cpp
namespace A::B {
	inline namespace C {
		int foo() { return 5; }
	}
}

namespace A {
	inline namespace B {
		namespace C {
			int foo() { return 5; }
		}
	}
}
```

inline 可以出现在除了第一个 namespace 之外的任意 namespace 前。

