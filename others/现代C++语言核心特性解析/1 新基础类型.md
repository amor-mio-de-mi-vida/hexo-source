---
date: 2024-11-21 20:22:55
date modified: 2024-11-22 19:17:41
title: 新基础类型
tags:
  - cpp
categories:
  - cpp
---
## 整数类型 `long long`

我们知道long通常表示一个32位整型，而long long则是用来表示一个64位的整型。C++标准还为其定义LL和ULL作为这两种类型的字面量后缀，所以在初始化long long类型变量的时候可以这么写：

```cpp
long long x = 65536LL;
```

当然，这里可以忽略LL这个字面量后缀，直接写成下面的形式也可以达到同样的效果：

```cpp
long long x = 65536;
```

要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：

```cpp
long long x1 = 65536 << 16; // 计算得到的 x1 值为0
std::cout << "x1 = " << x1 << std::endl;

long long x2 = 65536LL << 16; //计算得到的x2值为 4294967296（0x100000000）
std::cout << "x2 = " << x2 << std::endl;
```

和其他整型一样，long long也能运用于枚举类型和位域，例如：

```cpp
enum lonnglong _num : long long {
	x1, 
	x2
};

struct longlong_struct {
	long long x1 : 8;
	long long x2 : 24;
	long long x3 : 32;
};

std::cout << sizeof(longlong_enum::x1) << std::endl; // 输出大小为8
std::cout << sizeof(longlong_struct) << std::endl // 输出大小为8
```

作为一个新的整型long long，C++标准必须为它配套地加入整型的大小限制。在头文件中增加了以下宏，分别代表long long的最大值和最小值以及unsigned long long的最大值：

```cpp
#define LLONG_MAX 9223372036854775807LL // long long的最大值
#define LLONG_MIN (-9223372036854775807LL - 1) // long long的最小值
#define ULLONG_MAX 0xffffffffffffffffULL // unsigned long long的最大值
```

C++标准中对标准库头文件做了扩展，特化了long long和 unsigned long long版本的numeric_ limits类模板。这使我们能够更便捷地获取这些类型的最大值和最小值

```cpp
#include <iostream>
#include <limits>
#include <cstdio>
int main(int argc, char* argv[]) {
	// 使用宏方法
	std::cout << "LLONG_MAX = " << LLONG_MAX << std::endl;
	std::cout << "LLONG_MIN = " << LLONG_MIN << std::endl;
	std::cout << "ULLONG_MAX = " << ULLONG_MAX << std::endl;
	
	// 使用类模版方法
	std::cout << "std::numeric_limits<long long>::max() = " << std::numeric_limits<long long>::max() << std::endl;
	std::cout << "std::numeric_limits<long long>::min() = " << std::numeric_limits<long long>::min() << std::endl;
	std::cout << "std::numeric_limits<unsigned long long>::max() = " << std::numeric_limits<unsigned long long>::max() << std::endl;
	// 使用 printf 打印输出
	std::printf("LLONG_MAX = %lld\n", LLONG_MAX);
	std::printf("LLONG_MIN = %lld\n", LLONG_MIN);
	std::printf("ULLONG_MAX = %ullu\n", ULLONG_MAX);
}
```

## 新字符类型`char16_t` 和 `char32_t`

在C++11标准中添加两种新的字符类型char16_t和char32_t，它们分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法。

UTF-8、UTF-16和UTF-32简单来说是使用不同大小内存空间的编码方法。

UTF-32是最简单的编码方法，该方法用一个32位的内存空间（也就是4字节）存储一个字符编码，由于Unicode字符集的最大个数为0x10FFFF（ISO 10646），因此4字节的空间完全能够容纳任何一个字符编码。UTF-32编码方法的优点显而易见，它非常简单，计算字符串长度和查找字符都很方便；缺点也很明显，太占用内存空间。

UTF-16编码方法所需的内存空间从32位缩小到16位（占用2字节），但是由于存储空间的缩小，因此UTF-16最多只能支持0xFFFF个字符，这显然不太够用，于是UTF-16采用了一种特殊的方法来表达无法表示的字符。简单来说，从0x0000～0xD7FF以及0xE000～0xFFFF直接映射到Unicode字符集，而剩下的0xD800～0xDFFF则用于映射0x10000～0x10FFFF的Unicode字符集，映射方法为：字符编码减去0x10000后剩下的20比特位分为高位和低位，高10位的映射范围为0xD800～0xDBFF，低10位的映射范围为0xDC00～0xDFFF。例如0x10437，减去0x10000后的高低位分别为0x1和0x37，分别加上0xD800和0xDC00的结果是0xD801和0xDC37。

幸运的是，一般情况下0xFFFF足以覆盖日常字符需求，我们也不必为了UTF-16的特殊编码方法而烦恼。UTF-16编码的优势是可以用固定长度的编码表达常用的字符，所以计算字符长度和查找字符也比较方便。另外，在内存空间使用上也比UTF-32好得多。

最后说一下我们最常用的UTF-8编码方法，它是一种可变长度的编码方法。由于UTF-8编码方法只占用8比特位（1字节），因此要表达完数量高达0x10FFFF的字符集，它采用了一种前缀编码的方法。这个方法可以用1～4字节表示字符个数为0x10FFFF的Unicode（ISO 10646）字符集。为了尽量节约空间，常用的字符通常用1～2字节就能表达，其他的字符才会用到3～4字节，所以在内存空间可以使用UTF-8，但是计算字符串长度和查找字符在UTF-8中却是一个令人头痛的问题。

### 使用新字符类型 `char16_t` 和 `char32_t`

对于UTF-8编码方法而言，普通类型似乎是无法满足需求的，毕竟普通类型无法表达变长的内存空间。所以一般情况下我们直接使用基本类型char进行处理，而过去也没有一个针对UTF-16和UTF-32的字符类型。到了C++11，char16_t和char32_t的出现打破了这个尴尬的局面。除此之外，C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀u8、UTF-16的前缀u和UTF-32的前缀U：

```cpp
char utf8c = u8'a';
// char utf8c = u8'好';
char16_t utf16c = u'好';
char32_t utf32c = U'好';
char utf8[] = u8"你好世界";
char16_t utf16[] = u"你好世界";
char32_t utf32[] = U"你好世界";
```

### `wchr_t` 存在的问题

在C++98的标准中提供了一个`wchar_t`字符类型，并且还提供了前缀L，用它表示一个宽字符。事实上Windows系统的API使用的就是`wchar_t`，它在Windows内核中是一个最基础的字符类型。`wchar_t`确实在一定程度上能够满足我们对于字符表达的需求，但是起初在定义`wchar_t`时并没有规定其占用内存的大小。于是就给了实现者充分的自由，以至于在Windows上`wchar_t`是一个16位长度的类型（2字节），而在Linux和macOS上`wchar_t`却是32位的（4字节）。这导致了一个严重的后果，我们写出的代码无法在不同平台上保持相同行为。而`char16_t`和`char32_t`的出现解决了这个问题，它们明确规定了其所占内存空间的大小，让代码在任何平台上都能够有一致的表现。

### 新字符串连接

如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀。如果其中一个字符串字面量没有前缀，则将其视为与另一个字符串字面量具有相同前缀的字符串字面量，其他的连接行为由具体实现者定义。

### 库对新字符类型的支持

C11增加了4个字符的转换函数，包括：

```cpp
size_t mbrtoc16( char16_t* pc16, const char* s, size_t n, mbstate_t* ps );

size_t c16rtomb( char* s, char16_t c16, mbstate_t* ps );

size_t mbrtoc32( char32_t* pc32, const char* s, size_t n, mbstate_t* ps );

size_t c32rtomb( char* s, char32_t c32, mbstate_t* ps );
```

除此之外，C++标准库的字符串也加入了对新字符类型的支持，例如：

```cpp
using u16string = basic_string;
using u32string = basic_string;
using wstring = basic_string;
```

### `char8_t` 字符类型

使用`char`类型来处理UTF-8字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称以区分普通字符和UTF-8字符。C++20标准新引入的类型`char8_t`可以解决以上问题，它可以代替`char`作为UTF-8的字符类型。`char8_t`具有和`unsigned char`相同的符号属性、存储大小、对齐方式以及整数转换等级。引入`char8_t`类型后，在C++17环境下可以编译的UTF-8字符相关的代码会出现问题，例如：

```cpp
char std[] = u8"text"; // c++ 编译成功; c++20编译失败,需要char8_t
char c = u8'c';
char8_t c8a[] = "text"; // C++20编译失败，需要char
char8_t c8 = 'c';
```

另外，为了匹配新的char8_t字符类型，库函数也有相应的增加：

```cpp
size_t mbrtoc8(char8_t* pc8, const char* s, size_t n, mbstate_t* ps);

size_t c8rtomb(char* s, char8_t c8, mbstate_t* ps);

using u8string = basic_string;
```


